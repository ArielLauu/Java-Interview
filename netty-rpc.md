[TOC]

### 实现一个 RPC 框架

#### 1. 重要的部分

1. 注册中心
2. 网络传输
3. 序列化和反序列化
4. 动态代理
5. 负载均衡
6. 传输协议

### 2. 面试问题

#### 2.1 序列化

**2.1.1谈谈项目中几种序列化方式的不同点**

- Kryo 是专门针对Java语言序列化方式并且性能非常好

kryo的设计目的是指对象值的序列化，关注的是有效数据的传输，减少需要序列化的元数据信息。

这一点通过Kryo对Class对象的序列化，也就是类型的序列化就能看出端倪。Kryo对Class的序列化只需要化Class的全路径名，在反序列化时根据Class通过类加载进行加载，大大减少了序列化后的文件大小，能极大提高性能。

Kryo的核心设计理念就是尽最大可能减少序列化后的文件大小，其举措1就是通过对long,int等数据类型，采用变长字节存储来代替java中使用固定字节(4,8)字节的模式，因为在软件开发中，对象的这些值基本上都是小值，能节省很多空间，第二个举措是使用了类似缓存的机制，在一次序列化对象中，在整个递归序列化期间，相同的对象，只会序列化一次，后续的用一个局部int值来代替。

- Protobuf出自于Google，性能还比较优秀，也支持多种语言，同时还是跨平台的。就是在使用中过于繁琐，因为你需要自己定义 IDL 文件和生成对应的序列化代码。这样虽然不然灵活，但是，另一方面导致protobuf没有序列化漏洞的风险。

- Protostuff 基于Google protobuf，但是提供了更多的功能和更简易的用法。虽然更加易用，但是不代表 ProtoStuff 性能更差

**2.1.2 序列化是怎么做的？**

定义序列化和反序列化接口，SPI机制来使用具体的实现类，在消息编码和解码的时候使用序列化

**2.1.3 为什么需要序列化**

网络传输的数据必须是二进制，Java 对象没办法直接在网络中传输。为了能够让 Java 对象在网络中传输我们需要将其**序列化**为二进制的数据。我们最终需要的还是目标 Java 对象，因此我们还要将二进制的数据“解析”为目标 Java 对象，也就是对二进制数据再进行一次**反序列化**

序列化怎么做的？Kryo原理了解吗？ 
序列化怎么实现?
主要是Kryo（两个特点介绍了一下）
那你这个序列化还是针对Java语言的，如何实现跨语言的序列化或者rpc框架？

- 了不不了解hessian协议（不太了解），Hessian2 ， protobuf



#### 2.2 Netty

**2.2.1 谈谈为什么会发生粘包黏包, 粘包拆包解决办法？**

粘包并不是 TCP 协议造成的，它的出现是因为应用层协议设计者对 TCP 协议的错误理解，忽略了 TCP 协议的定义并且缺乏设计应用层协议的经验。TCP 协议是面向字节流的协议，它可能会组合或者拆分应用层协议的数据。应用层协议的没有定义消息的边界导致数据的接收方无法拼接数据，明显的表现就是 send了两次但是只需要 receive一次，send两次的数据连在一起。

解决的方法: 使用编码解码器（序列化反序列化）

**2.2.2 为啥要用Netty 而不是 NIO？**

1. 在 NIO 中需要自己构建 ByteBuffer 从 Channel 中读取数据，而 Netty 中数据是直接读取完成存放在 ByteBuf 中的。相当于省略了用户进程从内核中复制数据的过程。
2. 在 Netty 中,可以使用自带的编码解码器，解决 TCP 粘包读半包问题。

**2.2.3 心跳机制** 

[ IO 模型 ](http://www.52im.net/thread-1935-1-1.html)

[Epoll 总结](https://blog.csdn.net/qq_37654024/article/details/57069246?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.control&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.control)

BIO 和 NIO的区别？
如果要实现内存零拷贝怎么做？
除了NIO,还有什么？（BIO AIO）
为什么选用[Netty]()来做通信框架？ 
还知道其他网络通信框架？
netty高性能主要依赖了哪些特性？（ [主从 Reactors 多线程模型](https://zhuanlan.zhihu.com/p/76498988) ）
netty bytebuf工作原理，和NIO里buffer区别？

ByteBuffer缓冲区的长度固定，分多了会浪费内存，分少了存放大的数据时会索引越界，所以会有确保空间以及重新分配的问题

![image-20210212160917136](/Users/yaojiang/Library/Application Support/typora-user-images/image-20210212160917136.png)除了Select，还有什么（Poll Epoll，区别是什么)

#### 2.3 RPC

**2.3.1 什么是RPC框架？主流RPC框架有哪些？为啥要用 RPC框架?** 

**RPC（Remote Procedure Call）**即远程过程调用

**为什么要 RPC  ？**因为，两个不同的服务器上的服务提供的方法不在一个内存空间，所以，需要通过网络编程才能传递方法调用所需要的参数。并且，方法调用的结果也需要通过网络编程来接收。但是，如果我们自己手动网络编程来实现这个调用过程的话工作量是非常大的，因为，我们需要考虑底层传输方式（TCP还是UDP）、序列化方式等等方面

常见RPC : Dubbo / gRPC
除了Dubbo，还了解其他RPC框架吗（gRPC, Thirft 有什么区别）
能聊聊gRPC和dubbo这两类框架区别？
Java里的RMI了解吗？（不太了解）

**2.3.2 RPC的工作过程**

序列化怎么做的？Kryo原理了解吗？ 

**2.3.3 如果让你自己设计一个RPC框架该如何做？**



#### 2.4 ZooKeeper

**2.4.1 ZooKeeper的心跳机制,以及选择 leader 的过程**

**2.4.2 ZooKeeper的ZAB算法与Paxos的本质区别是什么？**

Zoo[keep]()er有几种角色？ 

![image-20210213223050176](https://typora-image-elias.oss-cn-hangzhou.aliyuncs.com/uPic/image-20210213223050176.png)
Zoo[keep]()er集群节点宕机了怎么发现剔除的？
为什么用Zoo[keep]()er做注册中心(优点，与其他选型对比下) 
介绍一下服务注册中心怎么做的？
用了注册中心了吗？注册中心承担了什么职责？使用的什么来做注册中心的？ 
服务注册原理
分布式数据一致性协议都知道哪些（2PC 3PC Paxos），Raft了不了解

#### 2.5 项目本身

**项目中负载均衡怎么实现的**
**做了负载均衡吗？实现了哪些负载均衡策略？**
**负载均衡了解哪些([dubbo的四种策略](https://dubbo.apache.org/zh/docs/v2.7/user/examples/loadbalance/)说了下)**
**Dubbo为什么推荐基于随机的负载均衡？** 
在一个截面上碰撞的概率高，但调用量越大分布越均匀，而且按概率使用权重后也比较均匀，有利于动态调整提供者权重

**一致性哈希在某节点宕机时怎么保证一致性的？** 
**一致性哈希比其他方法的优点？（当增加或减少服务节点时，不会造成[哈希表]()的全量重新映射，而是增量式的重新映射）**

​	可扩展性,一致性哈希算法保证了增加或减少服务器时，数据存储的改变最少

​	更好地适应数据的快速增长, 即使数据在虚拟节点上分布不均衡，也可可以将包含数据多的虚拟节点分裂或者调整部分虚拟节点的存储分布

通信协议是如何设计的？ 

**为啥要用动态代理呢？JDK自带的动态代理有啥问题不？** 

RPC 的主要目的就是让我们调用远程方法像调用本地方法一样简单，我们不需要关心远程方法调用的细节比如网络传输。答案就是动态代理。简单来说，当你调用远程方法的时候，实际会通过代理对象来传输网络请求，不然的话，怎么可能直接就调用到远程方法。

- 使用动态代理的对象必须实现一个或多个接口
- 使用cglib代理的对象则无需实现接口，达到代理类无侵入。



SPI机制
有没有提供什么扩展的接口，钩子给其人或程序方便扩展。

实现高性能的RPC关键在于哪些方面（我从序列化，通信协议，IO模型三个方面回答）
容器了解什么（只了解点Docker）
整体服务调用链路是怎样的？
JDK 动态代理机制是怎么实现的（反射，再底层原理不太清楚）
RPC中是用Spring进行管理的，那用到了事务吗（没有）
介绍一下你理解的Spring。 
依赖注入有哪写方式？ 








