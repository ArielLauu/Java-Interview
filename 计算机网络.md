## 计算机网络

[TOC]

#### http访问页面的流程

https://segmentfault.com/a/1190000006879700

1. DNS解析：域名—>IP地址（**DNS协议**）

   本地域名服务器—根域名服务器—顶级域名服务器—主域名服务器

   ![DNS解析过程](https://typora-image-ariellauu.oss-cn-beijing.aliyuncs.com/uPic/bVDM45.jpg)

   **DNS缓存：**浏览器缓存—>JVM DNS缓存—>本机操作系统缓存—>路由器缓存—>根域名服务器—>COM顶级域名服务器—>主域名服务器

2. TCP连接（**TCP协议**）

3. 发送HTTP请求（HTTPS传送数据前进行加密）

   **IP：**TCP建立连接后，发送数据在网络层使用IP协议

   **OSPF **(Open shortest path first)：IP数据包在路由选择时使用该协议

   **ARP：**路由器与服务器通信时，将IP地址转换为MAC地址的协议

   **HTTP：**应用层传输协议

4. 服务器处理HTTP请求并返回HTTP报文

5. 浏览器解析渲染页面

6. 连接结束

---

#### IP协议中子网掩码作用

子网掩码就是用来**遮掩IP地址**并**划分网段**的工具，根据**遮掩的位数不同**来划分不同的网段。能够将某个IP地址划分成**网络地址**和**主机地址**两部分

https://www.zhihu.com/question/56895036

---

#### OSI七层模型

![五层体系结构](https://typora-image-ariellauu.oss-cn-beijing.aliyuncs.com/uPic/%E4%BA%94%E5%B1%82%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.png)

- **应用层**：通过进程间的交互，来完成特性的网络应用。应用层定义的是**应用进程间通信和交互的规则**
  
  - 协议：如**域名系统DNS**，支持万维网应用的 **HTTP协议**，支持电子邮件的 **SMTP协议**
  
- **运输层**：负责向两台主机进程之间的通信提供**通用的数据传输服务**

  传输控制协议 **TCP**（Transmission Control Protocol)，用户数据协议 **UDP **(User Datagram Protocol)

- **网络层**：在计算机网络进行通信的两个计算机之间，可能会通过很多**数据链路**和**通信子网**。网络层的任务就是选择合适的**网间路由**和**交换结点**， 确保数据及时传送

  **IP** 协议，因此分组也叫 **IP** 数据报

- **数据链路层**

  主机之间的数据传输，总是在一段一段的链路 上传送的，这就需要使用专⻔的链路层的协议。**数据链路层将网络层交下来的 分组（IP 数据报）组装成帧**，在两个相邻节点间的链路上传送帧。每一帧包括数据和必要的控制信息

- **物理层**

  实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体**传输介质**和**物理设备**的差异

---

#### TCP三次握、四次挥手

https://blog.csdn.net/qzcsu/article/details/72861891

##### Sequence Number怎么设置的

**序号**：占4个字节，TCP连接中传送的字节流中的每个字节都按顺序编号，它标示**该数据报文段第一个字节的编号**。例如，一段报文的序号字段值是 301 ，而携带的数据共有100字段，显然下一个报文段（如果还有的话）的数据序号应该从401开始；

**确认号**：占4个字节，是**期望收到对方下一个报文的第一个数据字节的序号**。例如，B收到了A发送过来的报文，其序列号字段是501，而数据长度是200字节，这表明B正确的收到了A发送的到序号700为止的数据。因此，B期望收到A的下一个数据序号是701，于是B在发送给A的确认报文段中把确认号置为701；

---

#### TCP滑动窗口原理，作用

**作用**：实现流量控制，控制发送方的发送速率，保证接收方来得及接受

**原理**：

- 发送方和接收方各有一个窗口，用来暂时存放字节流。窗口内的字节都允许被发送or接收
- 接收方通过TCP报文中的窗口字段，告诉发送方自己的窗口大小，发送方依此设置自己窗口大小
- 发送方的窗口，会不断右滑，直到第一个字节不是已发送且已确认的状态。
- 接收方同理，但是只对窗口内**按序到达**的最后一个字节进行确认。



![img](https://typora-image-ariellauu.oss-cn-beijing.aliyuncs.com/uPic/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f61333235336465622d386432312d343061312d616165342d3764313738653461613331392e6a7067.jpg)

---

#### TCP拥塞控制方法

- **慢开始**：当开始一个连接时，用单个报文作为单位，设置拥塞窗口（cwnd）大小为1，如果确认到达且未丢失，则翻倍增长，变为2个、4个…直到到达慢开始门限ssthresh，进入拥塞避免

- **拥塞避免**：设置慢开始门限ssthresh，`cwnd<ssthresh`时，慢开始；`cwnd>=ssthresh`时，使用拥塞控制算法，停用慢开始，cwnd每次加1。如果出现了超时，另`ssthresh=cwnd/2`，重新执行慢开始

![img](https://typora-image-ariellauu.oss-cn-beijing.aliyuncs.com/uPic/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f39313066363133662d353134662d343533342d383764642d3962343639396435396433312e706e67.jpg)

- **快重传**：接收方收到一个比期望序号大的报文段以后，便会重复最近一次确认的报文段的确认信号，直到3次以后，发送端会知道该报文段丢失，于是重新发送，而不用等到超时再重传。
- **快恢复**：发送方收到3个重复确认时，将慢开始门限`ssthresh=cwnd/2`，`cwnd=ssthresh`，然后执行拥塞避免算法，使拥塞窗口慢慢变大

注：tcp的数据发送窗口取rwnd和cwnd的较小值，滑动窗口和拥塞控制关系： https://www.zhihu.com/question/264518499

<img src="https://typora-image-ariellauu.oss-cn-beijing.aliyuncs.com/uPic/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f66363162353431392d633934612d346466312d386434642d6165643961653863633664352e706e67.jpg" alt="img" style="zoom:80%;" />

---

#### TCP可靠原因

1. 应用数据被TCP分割成认为最适合发送的数据块
2. **校验和**：维持首部和数据的校验和，目的是检测数据在传输过程中的变化。如果收到的校验和有问题，则丢弃和不确认收到此数据
3. 丢弃重复数据
4. **流量控制**：TCP滑动窗口控制双方的发送速率，以保证能及时接受数据
5. **拥塞控制**：网络拥塞时，减少数据的发送
6. **ARQ协议**：也是为了实现可靠传输。基本原理是发送完一个分组就停止发送，等待对方确认后再发送下一个分组。
7. **超时重传**：TCP发出一个数据段后，启动一个计时器，等待目的端收到这个数据。如果不能及时收到确认，则会重新发送，并重启计时。

---

#### UDP和TCP区别

UDP：

- 传输数据不需要连接，不保证可靠交付

- 面向数据报文段
- 支持一对一/一对多/多对多
- 没有拥塞控制，不会因为网络拥塞影响传输速率
- 传输速度快
- 一般用于即时通信

TCP：

- 提供面向连接的，可靠的数据传输。
- 面向字节流
- 不支持广播/多播，只能一对一
- 在数据传输时，有确认/窗口/重传/拥塞控制等机制，增加了许多消耗，速率比udp慢
- TCP 一般用于文件传输、发送和接收邮件、远程登录等场景

![TCP、UDP协议的区别](https://typora-image-ariellauu.oss-cn-beijing.aliyuncs.com/uPic/tcp-vs-udp.jpg)

---

#### HTTP GET和POST

- 二者本质上没有区别，都是HTTP协议中**两种请求方式**，只有报文格式不同
- 根据规范，`get`将参数放在`url`中，`post`放在`requestBody`中
- 由于浏览器限制`url`长度，所以`get`参数长度会受到限制

---

#### HTTP和HTTPS的区别

1. **端口**：HTTP的URL由“http://”起始且默认使用端口80，而HTTPS的URL由“https://”起始且默认使用端口443
2. **安全性和资源消耗**：
   - HTTP运行在TCP之上，明文传输，通信双方无法验证对方身份
   - HTTPS运行在SSL/TLS之上，SSL/TLS运行在TCP之上，通过对称加密传输，但是对称加密的密钥通过服务器的证书，进行了非对称加密。所以HTTPS安全性和资源消耗都高于HTTP

---

#### 介绍HTTPS及其加密过程

- `HTTPS = HTTP + TLS/SSL协议`，`HTTPS`协议让`HTTP`先和`SSL（Secure Sockets Layer）`通信，再由`SSL`和`TCP`通信，具有**加密（防窃听）**、**认证（防伪装）**和**完整性保护（防报文篡改）**的功能 

<img src="https://typora-image-ariellauu.oss-cn-beijing.aliyuncs.com/uPic/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f73736c2d6f66666c6f6164696e672e6a7067.jpg" alt="img" style="zoom:67%;" />

**加密过程**

- 对称加密的问题：如何安全将秘钥传到解密方。
- 非对称加密：细节繁琐,速度太慢

  **证书申请及验证：**

  - 服务端生成公私秘钥，将秘钥和信息发送给CA（Certificate Authority），CA根据信息生成证书。
  - 对于服务器公钥，CA根据数字摘要算法，生成数字指纹，再用CA私钥对数字指纹进行加密，生成数字签名。
  - 证书包含：网站地址，服务器公钥，证书的颁发机构（CA），签名算法，签名等
  - 客户端验证证书的时候，用CA证书的公钥，解密签名得到数字指纹A，然后对证书的服务器公钥进行数字摘要算法，生成数字指纹B，比较数字指纹A和B是否相等=》相等，说明证书内容未被篡改=》验证证书有效期和域名等

  **SSL四次握手**：

  - https://www.jianshu.com/p/cf2f86bc597a 解释了下图

  ![未命名图片](https://typora-image-ariellauu.oss-cn-beijing.aliyuncs.com/uPic/%E6%9C%AA%E5%91%BD%E5%90%8D%E5%9B%BE%E7%89%87.png)

1. 客户端生成`Random_C`，将随机数`Random_C`、自己支持的SSL版本号、加密算法等信息发送给服务器

2. 服务器生成`Random_S`，将随机数`Random_S`、选定的加密算法、`Hash`算法、CA证书等发给客户端

3. 客户端用CA公钥验证证书的有效性

   =》生成随机数`Pre-master secret，利用Random_C、Random_S、Pre-master key`计算得到对称秘钥

   =》使用约定的`Hash`算法计算握手信息，用对称秘钥加密

   =》客户端使用`change cipher spec`通知server端开始使用加密报文传输数据

   =》客户端将加密的握手信息，和用证书中的`S.pub`加密后的`Pre-master secret`发给服务器。

4. 服务器用`S.pri`解密`Pre-master secret`，结合`Random_C、Random_S`计算得到对称秘钥

   =》使用约定的`Hash`算法计算握手信息

   =》用计算所得对称秘钥解密客户端发来的信息，验证秘钥正确性

   =》服务端传输改变通知（Change Chiper Spec）

   =》根据握手信息生成数据，并使用对称秘钥加密，发给客户端

   =》验证完毕，双方通过对称秘钥 加密/解密数据进行通信

---

#### IO模型

大多数文件系统的默认 I/O 操作都是缓存 I/O。在 Linux 的缓存 I/O 机制中，操作系统会将 I/O 的数据缓存在文件系统的页缓存（ page cache ）中，也就是说，数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间

所以说，当一个read操作发生时，它会经历两个阶段：

1. 等待数据准备
2. 将数据从内核拷贝到进程中

阻塞IO和非阻塞IO的区别在于第一步发起IO请求是否会被阻塞：如果阻塞直到完成那么就是传统的阻塞IO，如果不阻塞，那么就是非阻塞IO

同步IO和异步IO的区别就在于第二个步骤是否阻塞: 如果不阻塞，而是操作系统帮你做完IO操作再将结果返回给你，那么就是异步IO

还有一个说法**非阻塞I/O 系统调用( nonblocking system call )** 和 **异步I/O系统调用 （asychronous system call）**的区别是：

- 一个**非阻塞I/O 系统调用 read()** 操作立即返回的是任何可以立即拿到的数据， 可以是完整的结果， 也可以是不完整的结果， 还可以是一个空值。
- 而**异步I/O系统调用** read（）结果必须是完整的， 但是这个操作完成的通知可以延迟到将来的一个时间点。



1. **阻塞IO** 

   进程阻塞在 recvfrom

   等待客户端准备好数据，等待将数据从内核空间拷贝到用户空间

2. **非阻塞IO**

   进程一直轮询 recvfrom

   不需要等待客户端准备好数据，等待将数据从内核空间拷贝到用户空间

3. **信号驱动IO**

   使用套接口进行信号驱动 I/O，并安装一个信号处理函数，进程继续运行并不阻塞

4. **IO多路复用**

   使用channel通信，channel 的底层还是使用的 socket 进行通信，但是多个 channel 只对应一个 socket

5. **异步IO**

   信号驱动 I/O 是由内核通知应用程序何时启动一个 I/O 操作，而异步 I/O 模型是由内核通知应用程序 I/O 操作何时完成 ![image-20210220142724891](https://typora-image-elias.oss-cn-hangzhou.aliyuncs.com/uPic/image-20210220142724891.png)

   

   [Ref 1](http://www.52im.net/thread-1935-1-1.html) [Ref 2](https://github.com/doocs/source-code-hunter/blob/main/docs/Netty/IOTechnologyBase/把被说烂的BIO、NIO、AIO再从头到尾扯一遍.md) [Epoll 总结](https://blog.csdn.net/qq_37654024/article/details/57069246?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.control&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.control)

   

   #### 2. Select, Poll, Epoll

   Linux “一切皆文件”，指的是，对所有文件（目录、字符设备、块设备、套接字、打印机、进程、线程、管道等）操作，读写都可用fopen()/fclose()/fwrite()/fread()等函数进行处理。屏蔽了硬件的区别，所有设备都抽象成文件，提供统一的接口给用户。

   **文件描述符**(fd, File descriptor)用来操作一个已经打开的文件，形式上是一个非负整数，指向内核为每一个进程所维护的该进程打开文件的记录表

   I/O多路复用就是通过一种机制，一个进程可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作

   

   ```
   int select (int n, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);
   
   int poll (struct pollfd *fds, unsigned int nfds, int timeout);
   struct pollfd {
       int fd; /* file descriptor */
       short events; /* requested events to watch */
       short revents; /* returned events witnessed */
   };
   
   //创建一个epoll的句柄，size用来告诉内核这个监听的数目一共有多大
   int epoll_create(int size)；
   int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)；
   //等待epfd上的io事件，最多返回maxevents个事件。
   int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout);
   ```

   **1. Select**

   文件描述符分3类，分别是writefds、readfds、和exceptfds。调用后select函数会阻塞，直到有描述符就绪（有数据 可读、可写、或者有except），或者超时（timeout指定等待时间，如果立即返回设为null即可），函数返回。当select函数返回后，可以通过遍历fdset，来找到就绪的描述符

   **缺陷:**  需要轮询所有fd，时间复杂度 O(n) n有上限1024(32位),2048(64位) fd集合会从用户态拷贝到内核态

   **2. Poll**

   实现和select非常相似，只是描述fd集合的方式不同，没有最大连接数的限制（原因是它是基于链表来存储的）

   **缺陷:**  需要轮询所有fd，时间复杂度 O(n) fd集合会从用户态拷贝到内核态 水平触发（LT），如果报告了fd后，没有被处理，那么下次poll时会再次报告该fd

   **3. Epoll**

   **epoll可以理解为event poll**，**一旦基于某个文件描述符就绪时，内核会采用类似callback的回调机制，迅速激活这个文件描述符，当进程调用epoll_wait() 时便得到通知**。(此处去掉了遍历文件描述符，而是通过监听回调的机制)

   **优点:**  通过监听回调机制，时间复杂度是 O(1) 内存拷贝，利用mmap()文件映射内存加速与内核空间的消息传递；即epoll使用mmap减少复制开销 没有最大并发连接的限制，能打开的FD的上限远大于1024 支持边缘触发(ET)

   **5. 两种触发模式**

   LT是默认的模式，ET是“高速”模式。LT模式下，只要这个fd还有数据可读，每次 epoll_wait都会返回它的事件，提醒用户程序去操作，而在ET（边缘触发）模式中，它只会提示一次，直到下次再有数据流入之前都不会再提示了，无论fd中是否还有数据可读。

   **ET 模式比水平触发效率高，系统不会充斥大量你不关心的就绪文件描述符**

   如果采用EPOLLLT模式的话，系统中一旦有大量你不需要读写的就绪文件描述符，它们每次调用epoll_wait都会返回，这样会大大降低处理程序检索自己关心的就绪文件描述符的效率.。而采用EPOLLET这种边沿触发模式的话，当被监控的文件描述符上有可读写事件发生时，epoll_wait()会通知处理程序去读写。如果这次没有把数据全部读写完(如读写缓冲区太小)，那么下次调用epoll_wait()时，它不会通知你，也就是它只会通知你一次，直到该文件描述符上出现第二次可读写事件才会通知你

   