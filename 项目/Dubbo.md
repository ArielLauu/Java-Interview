## Dubbo

[TOC]

#### 项目中负载均衡怎么实现的

实现了两种，**一致性哈希**和**随机**负载均衡算法

---

#### 负载均衡了解哪些

**1. RandomLoadBalance**：随机负载均衡算法，Dubbo默认的负载均衡策略

- 如果权重一致随机取出，如果不同则累加权重，然后按照权重比例随机取出

**2. RoundRobinLoadBalance**：轮询负载均衡算法，按公约后的权重设置轮循比率

- 参考自 Nginx 的平滑加权轮询负载均衡
- 过程：有两个参数，currentWeight和weight，currentWeight动态变化，weight固定。当有新的请求进来时，遍历服务器列表，让它的 currentWeight 加上自身权重。遍历完成后，找到最大的 currentWeight，并将其减去权重总和，然后返回相应的服务器即可
- **缺点**：在权重设置不合理的情况下，会**导致某些节点无法负载请求**，另外，如果有些机器性能比较低，**会存在请求阻塞的情况**

**3. LeastActiveLoadBalance**：最少活跃数负载均衡算法，会将请求负载到请求活跃数最少的节点上，如果节点上活跃数相同，则随机负载。

> 每个服务提供者对应一个活跃数 active。初始情况下，所有服务提供者活跃数均为0。每收到一个请求，活跃数加1，完成请求后则将活跃数减1。在服务运行一段时间后，性能好的服务提供者处理请求的速度更快，因此活跃数下降的也越快，此时这样的服务提供者能够优先获取到新的服务请求、这就是最小活跃数负载均衡算法的基本思想

**4. ConsistentHashLoadBalance**: 一致性Hash，相同参数的请求总是发到同一提供者。当某一台提供者挂时，原本发往该提供者的请求，基于虚拟节点，平摊到其它提供者，不会引起剧烈变动

- 构造函数中，每个实际的提供者均有160个（默认值，可调整）虚拟节点，每个提供者对应的虚拟节点将平均散列到哈希环上，当有请求时，先计算该请求参数对应的哈希值，然后顺时针寻找最近的虚拟节点，得到实际的提供者节点。

https://dubbo.apache.org/zh/docs/v2.7/dev/source/loadbalance/

---

#### 一致性哈希比其他方法的优点？

- 让虚拟节点在圆环上分散开来，避免**数据倾斜**。（数据倾斜是指，由于节点不够分散，导致大量请求落到了同一个节点上，而其他节点只会接收到了少量请求的情况）
- 在一些需要将同一个请求参数对应到同个服务的场景下很适合

- 当对实例进行增加或者删除的时候，不会造成哈希表的全量重新映射，而是增量式的重新映射，能避免引起很大的变动

---

#### 一致性哈希在某节点宕机时怎么保证一致性的

某服务节点宕机，服务会被影射到在环中，其前一个虚拟节点对应的服务提供者上

---

#### 除了Dubbo，还了解其他RPC框架吗（gRPC, Thrift, Dubbo 有什么区别）

**1. Dubbo**

由阿里开源，后面加入Apache，提供了三大核心能力：

- 面向接口的远程方法调用
- 智能容错和负载均衡
- 服务自动注册和发现

**2. gRPC**

gRPC是谷歌开源的，高性能的、通用的RPC框架。其主要面向移动应用开发，并基于HTTP2协议标准而设计，基于Protobuf序列化协议开发，支持众多语言

**3. Thrift**

是FaceBook开源的跨语言RPC框架，支持多种不同的编程语言

**对比：**

gRPC和Thrift虽然支持跨语言的调用，但是只提供了基本的RPC框架功能，缺乏一系列配套的服务化组件和服务治理功能的支撑。Dubbo不论是功能完善程度、生态系统还是社区活跃度，都很优秀。

但是Dubbo跨语言支持一般，主要还是支持Java

---

#### dubbo源码写的好的地方(待整理)



---

#### dubbo和java SPI机制

##### 1. Java SPI

**定义**：SPI（Service Provider Interface）是JDK内置的服务发现机制，用在不同模块间通过接口调用服务，避免对服务接口具体实现类的耦合。

**使用**：在项目的类路径下提供一个META/services/xx文件，配置一个文件，文件名为接口的全路径的名称，内容为具体的实现类全路径

> 比如JDBC的数据库驱动模块，不同数据库连接驱动接口相同但实现类不同，在使用SPI机制以前调用驱动代码需要直接在类里采用Class.forName(具体实现类全名）的方式调用，这样调用方依赖了具体的驱动实现，在替换驱动实现时要修改代码。
>
> 而采用SPI机制后，在驱动jar包的META-INF/services下面新建一个驱动接口全名的命名的文件，里面写上具体实现类的全名，这样调用方通过Java 的ServiceLoad接口动态的去加载接口的实现类，从而达到替换驱动实现不用修改代码的效果

**Java SPI的缺点：**

- **无法按需加载：**虽然 ServiceLoader 做了延迟载入，使用了LazyIterator，但是基本只能通过遍历全部获取，接口的实现类得全部载入并实例化一遍。如果你并不想用某些实现类，或者某些类实例化很耗时，它也被载入并实例化了，假如我只需要其中一个，其它的并不需要这就形成了一定的资源消耗浪费

- **不具有IOC的功能：**假如我有一个实现类，如何将它注入到我的容器中呢，类之间依赖关系如何完成呢

- **serviceLoader不是线程安全的**，会出现线程安全的问题

##### 2. Dubbo SPI机制

（1）**配置文件采用键值对配置的方式**，使用起来更加灵活和简单

（2）增强了原本SPI的功能，使得SPI具备**ioc和aop的功能**

[java与Dubbo SPI机制](https://www.cnblogs.com/wyq178/p/12171881.html)

---

#### dubbo不足，以及优化方向

**服务提供方与调用方接口依赖方式太强**：我们为每个微服务定义了各自的service抽象接口，并通过持续集成发布到私有仓库中，调用方应用对微服务提供的抽象接口存在强依赖关系，因此不论开发、测试、集成环境都需要严格的管理版本依赖，才不会出现服务方与调用方的不一致导致应用无法编译成功等一系列问题，以及这也会直接影响本地开发的环境要求，往往一个依赖很多服务的上层应用，每天都要更新很多代码并install之后才能进行后续的开发。若没有严格的版本管理制度或开发一些自动化工具，这样的依赖关系会成为开发团队的一大噩梦。而REST接口相比RPC更为轻量化，服务提供方和调用方的依赖只是依靠一纸契约，不存在代码级别的强依赖，当然REST接口也有痛点，因为接口定义过轻，很容易导致定义文档与实际实现不一致导致服务集成时的问题，但是该问题很好解决，只需要通过每个服务整合swagger，让每个服务的代码与文档一体化，就能解决。所以在分布式环境下，REST方式的服务依赖要比RPC方式的依赖更为灵活。

**服务对平台敏感，难以简单复用**：通常我们在提供对外服务时，都会以REST的方式提供出去，这样可以实现跨平台的特点，任何一个语言的调用方都可以根据接口定义来实现。那么在Dubbo中我们要提供REST接口时，不得不实现一层代理，用来将RPC接口转换成REST接口进行对外发布。若我们每个服务本身就以REST接口方式存在，当要对外提供服务时，主要在API网关中配置映射关系和权限控制就可实现服务的复用了。

