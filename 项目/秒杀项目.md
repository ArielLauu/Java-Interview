## 秒杀项目

[TOC]

#### 总结博客

项目回顾：https://blog.csdn.net/weixin_41891177/article/details/107775394

面经：https://blog.csdn.net/weixin_44406146/article/details/107800771

#### 如何解决库存超卖问题

秒杀场景下，并发会特别的大，有两种情况会导致库存卖超：

1. 一个用户同时发出了多个请求，如果库存足够，没加限制，用户就可以下多个订单。

2. 减库存的SQL上没有加库存数量的判断，并发的时候也会导致把库存减成负数。

对于`1.`前端加验证码，防止合法用户快速点鼠标同时发出多个请求，在后端的miaosha_order表中，对user_id和goods_id加唯一索引，确保就算是刷接口一个用户对一个商品绝对不会生成两个订单。

对于`2.`需要在扣减库存的SQL上加上库存数量的判断，只有扣减库存成功才可以生成订单：

![图片描述](https://typora-image-ariellauu.oss-cn-beijing.aliyuncs.com/uPic/5abc37b9000173f906870131.png)

---

#### 怎么使用ThreadLocal

- 在页面中很多地方都需要用于处于登录状态才能获取并操作该页面，我们无法为每一个controller中每个方法都执行获取用户的操作，我们可以在第一次登录时把用户保存到Cookie中或者session中

- **ThreadLocal存储user：**后端很多方法中都需要获取用户，我们没办法每次都去获取，我们可以在第一次获取到时把它保存到ThreadLocal中(一个用户操作对应一个线程，所以我们可以放心保存)，需要的时候直接拿出来使用

![image-20210216102527686](https://typora-image-ariellauu.oss-cn-beijing.aliyuncs.com/uPic/image-20210216102527686.png)

---

#### 秒杀库存如何设计的

- 商品表：很稳定，只包含商品的基本信息

- 秒杀商品表：商品基础信息+开始时间+结束时间+数量等

- 订单表：所有订单

- 秒杀订单表：秒杀相关的订单

如果每做一个活动，就在商品表添加字段标识一下，商品表会越来越难以维护，而且非常不稳定，惊颤会修改。订单表类似。所以创建新的秒杀商品表，通过商品id进行关联。

---

#### redis怎么用的，都存了什么

- **秒杀次数（防刷）**：对一个商品秒杀时，redis会记录某个用户对秒杀按钮的点击次数，超过5次直接返回”访问太频繁“提示
- **html（页面/url缓存）**
- **预加载的库存**：在秒杀的时候用来预减库存，防止大量无效请求穿透到数据库
- **秒杀path**：通过动态生成随机串UUID,结合用户ID和商品ID，生成path存入redis，并将path传给前端。前端获取path后，再根据path地址调用秒杀服务
- **验证码**：秒杀前需要输入验证码，作用为防刷限流，秒杀错峰
- **根据id和token缓存用户**：用于分布式session
- **秒杀订单**：判断用户是否已经下单，防止重复下单

---

#### 秒杀业务难点（待整理）

- 数据一致性：防止超卖和重复下单

---

#### 消息队列如何使用的

MQ 的核心场景：异步、解耦、削峰填谷

- **mq怎么用的？**

  Direct模式，Fanout模式，Topic模式，Header模

- **秒杀中mq的部分用到了什么设计模式**

  发布订阅模式

- **mq用了几个worker？如何保证顺序消费？**

  1. 为什么

  消息队列中的若干消息如果是对同一个数据进行操作，这些操作具有前后的关系，必须要按前后的顺序执行，否则就会造成数据异常

  2. 原因

  一个queue，有多个consumer去消费，这样就会造成顺序的错误，consumer从MQ里面读取数据是有序的，但是每个consumer的执行时间是不固定的，无法保证先读到消息的consumer一定先完成操作，这样就会出现消息并没有按照顺序执行，造成数据顺序错误

  一个queue，有多个consumer去消费，这样就会造成顺序的错误，consumer从MQ里面读取数据是有序的，但是每个consumer的执行时间是不固定的，无法保证先读到消息的consumer一定先完成操作，这样就会出现消息并没有按照顺序执行，造成数据顺序错误

  3. 保证顺序消费

  拆分多个queue，每个queue一个consumer，就是多一些queue而已，确实是麻烦点；这样也会造成吞吐量下降，可以在消费者内部采用多线程的方式取消费。

  或者就一个queue但是对应一个consumer，然后这个consumer内部用内存队列做排队，然后分发给底层不同的worker来处理

- **mq堵塞了怎么办？**



分布式锁怎么实现 什么时候加 加在什么上面

秒杀demo，秒杀业务都要哪些难点？对于这些难点都应该怎么解决（一直追问，用这个方法可能会有什么问题？数据量大到一定程度你的方法还行吗？等等等等）建议在准备项目的时候要对与项目的各个点要了如指掌，包括可能的缺陷等等

怎么保证用户不会重复秒秒杀？ 答：用redis的set结构记录已经参与过秒杀的用户。 追问：那如果有人用爬虫构造很多用户来刷你的秒杀，怎么办？ 答：在网关层做一个流量过滤器，分析流量特征，把流量特征异常的ip加入黑名单 

Redis怎么来保证它得可用性啊？ 集群。集群怎么实现啊？ （问了两次 ，可见这个部门redis用得很多）

3.关于秒杀项目的一系列问题:

(1)redis怎么用的，都存了什么？mq怎么用的？

(2)mq用了几个worker？如何保证顺序消费？

(3)压测的结论是什么？原因？

(4)如果持续增大并发量，哪个模块会出问题？如何解决？

(5)数据库主从复制的延时问题如何解决？

(6)mq堵塞了怎么办？

(7)多worker会不会对数据库产生压力？如何解决？

(8)如何避免重复下单？

(9)客户端如何知道自己下单成功？

4.设计模式知道哪些？

5.秒杀项目中用了什么设计模式？

6.秒杀中mq的部分用到了什么设计模式？

1.秒杀项目一系列问题（涉及到超卖，重复下单，数据不一致，交易系统，事务管理，客户端轮询反馈，第三方支付，数据库表的结构，各个表之间的关联等等）

秒杀系统介绍一下？为什么要引入redis？

秒杀系统压测了吗？如果继续增大并发量，那么接下来的瓶颈是什么？如何解决？（mq）

---

### 