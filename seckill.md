### 1. 基本的配置和命令

#### Redis 压测

```shell
redis-benchmark -h 127.0.0.1 -p 6379 -c 100 -n 100000
# 100并发 100000数量
redis-benchmark -h 127.0.0.1 -p 6379 -q -d 100
# 存取大小为100字节的数据
redis-benchmark -t set,lpush -n 100000 -q
# 只测试某些数值存取的性能
```

#### Jmeter 命令行

1. 录好脚本 jmx
2. 命令行 `sh jmeter.sh -n-t XXX.jmx -l result.jtl`
3. 将结果导入

#### 服务器环境

```
yum install git
yum install maven
```

[Docker-compose 安装](https://www.cnblogs.com/zxiaozhou/p/12950286.html)

[Docker 安装](https://juejin.cn/post/6844903965381885966)

### 2. 秒杀原项目流程

##### 常见的问题

1. **超卖问题**

   更新的时候判断库存大于0

2. **重复秒杀问题**

   user_id 和 good_id 创建一个唯一索引

##### 接口优化

1. **Redis预减库存减少数据库的访问**
   - 初始化商品库存到 redis
   - 收到请求redis减少库存
   - 请求入队
2. 内存标记减少 Redis 访问
3. Rabbitmq 异步下单
4. nginx水平扩展

##### 安全优化

1. **接口地址隐藏**

   - 接口带上 pathvariable
   - 添加生成地址的接口
   - 秒杀收到请求后先验证 pathvariable

2. **使用验证码**

3. **接口限流防刷**

   - 使用拦截器 `HandlerInterceptorAdapter`

     

### 3. 问题和优化

#### [Qiurunze](https://github.com/qiurunze123/miaosha) 里的


- [ ]  1. 通用缓存key的封装采用什么设计模式
- [ ]  2. redis的库存如何与数据库的库存保持一致
- [ ]  3. 为什么redis数量会减少为负数
- [ ]  4. 为什么要单独维护一个秒杀结束标志
- [ ]  5. rabbitmq如何做到消息不重复不丢失即使服务器重启
- [ ]  6. 为什么threadlocal存储user对象，原理
- [ ]  7. redis 分布式锁实现方法
- [ ]  8. 定时关单模拟与分布式锁
- [ ]  9. **RPC分布式补偿如何解决**
- [ ]  10. 分布式事务解决方案
- [ ]  11. 项目进行dubbo + zk 改造

#### 自己优化部分

- [x] 为了多线程安全，以前是Jedis+JedisPool组合 ,现在在SpringBoot 2.0应用中直接使用`Lettuce客户端的API封装`RedisTemplate即可`，`只要配置好连接池属性，那么SpringBoot就能自动管理连接池。
- [ ] 登录部分整合 Spring Security  



### 5. 面试问题

#### 5.1 业务相关

- **秒杀库存如何设计的**

  用 miaosha_good 表存储秒杀商品，秒杀商品有库存属性

- **如何防止超卖**

  有两种情况会导致库存卖超：

  （1）一个用户同时发出了多个请求，如果库存足够，没加限制，用户就可以下多个订单。

  （2）减库存的SQL上没有加库存数量的判断，并发的时候也会导致把库存减成负数。

  更新的时候判断库存大于0

- **如何防止重复秒杀**

  user_id 和 good_id 创建一个唯一索引

  用redis的set结构记录已经参与过秒杀的用户。 追问：那如果有人用爬虫构造很多用户来刷你的秒杀，怎么办

  在网关层做一个流量过滤器，分析流量特征，把流量特征异常的ip加入黑名单 

- **秒杀demo，秒杀业务都要哪些难点？对于这些难点都应该怎么解决（一直追问，用这个方法可能会有什么问题？数据量大到一定程度你的方法还行吗？等等等等）建议在准备项目的时候要对与项目的各个点要了如指掌，包括可能的缺陷等等**

  超卖问题，重复秒杀问题，接口限流防刷，内存标记

- **高并发下只有一个人能减库存那如果库存还有很多怎么办**

  Redis预减库存，消息队列

- **客户端如何知道自己下单成功**

  轮询或者等服务端异步通知

#### 5.2 Redis相关

- **Redis怎么来保证它得可用性啊？**

   [redis replication -> 主从架构 -> 读写分离 -> 水平扩容支撑读高并发](https://juejin.cn/post/6844903981148274701)

  redis 不能支持高并发主要是单机

  读写分离，一般来说，对缓存，一般都是用来支撑读高并发的，写的请求是比较少的，可能写请求也就一秒钟几千，一两千

- **分布式锁怎么实现 什么时候加 加在什么上面**

  分布式锁可以避免不同节点重复相同的工作，这些工作会浪费资源。比如用户下单之后有可能不同节点会发出多个反馈。

- **Redis怎么用的，都存了什么？**

  秒杀订单（ 防止重复下单，且不会打向数据库）

  用户数据（ 单点登录,分布式Session）

  商品库存（预减库存)

#### 5.3 消息队列相关

MQ 的核心场景：异步、解耦、削峰填谷

- **mq怎么用的？**

  Direct模式，Fanout模式，Topic模式，Header模

- **秒杀中mq的部分用到了什么设计模式**

  发布订阅模式

- **mq用了几个worker？如何保证顺序消费？**

  1. 为什么

  消息队列中的若干消息如果是对同一个数据进行操作，这些操作具有前后的关系，必须要按前后的顺序执行，否则就会造成数据异常

  2. 原因

  一个queue，有多个consumer去消费，这样就会造成顺序的错误，consumer从MQ里面读取数据是有序的，但是每个consumer的执行时间是不固定的，无法保证先读到消息的consumer一定先完成操作，这样就会出现消息并没有按照顺序执行，造成数据顺序错误

  一个queue，有多个consumer去消费，这样就会造成顺序的错误，consumer从MQ里面读取数据是有序的，但是每个consumer的执行时间是不固定的，无法保证先读到消息的consumer一定先完成操作，这样就会出现消息并没有按照顺序执行，造成数据顺序错误

  3. 保证顺序消费

  拆分多个queue，每个queue一个consumer，就是多一些queue而已，确实是麻烦点；这样也会造成吞吐量下降，可以在消费者内部采用多线程的方式取消费。

  或者就一个queue但是对应一个consumer，然后这个consumer内部用内存队列做排队，然后分发给底层不同的worker来处理

- **mq堵塞了怎么办？**



http://www.imooc.com/article/24671

3.关于秒杀项目的一系列问题:

(3)压测的结论是什么？原因？

(4)如果持续增大并发量，哪个模块会出问题？如何解决？

(5)数据库主从复制的延时问题如何解决？

(7)多worker会不会对数据库产生压力？如何解决？

4.设计模式知道哪些？

5.秒杀项目中用了什么设计模式

秒杀项目一系列问题（涉及到超卖，重复下单，数据不一致，交易系统，事务管理，客户端轮询反馈，第三方支付，数据库表的结构，各个表之间的关联等等）

秒杀系统介绍一下？为什么要引入redis？

秒杀系统压测了吗？如果继续增大并发量，那么接下来的瓶颈是什么？如何解决？（mq）