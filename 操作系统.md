## 操作系统

[TOC]

#### 1 进程之间通信

1. **管道/匿名管道** 
   - 半双工，数据往一个方向流动
   - 只能用于父子/兄弟进程之间
   - 数据FIFO，每次添加在尾部，从头部读
   - 存在于内存中
   - 读写进程必须同时在，否则阻塞
2. **有名管道**
   - 支持本机任意两个进程通信
   - FIFO，单向数据流
   - 管道的名字存储在文件系统，内容存放在内存，通过路径+文件名访问有名管道
   - 读写进程必须同时在，否则阻塞
3. **信号**：用于通知接收进程发生了某件事
4. **消息队列**
   - 存在于内核中的消息链表
   - 一个进程往队列写入消息时，并不需要另一个读进程在队列上等待消息到达
   - 支持消息随机查询，支持多个进程写入or读取
5. **共享内存**：内核中的一块区域。需要访问该区域的进程，将其映射到自己的私有地址空间，就可以直接进行数据的读写。需要依靠同步机制进行同步，如信号量
6. **信号量**：用于多进程对共享数据的访问，为非负整形变量，可被创建、等待或挂出
7. **套接字（socket)**：一种支持TCP/IP的通信机制，支持进程跨网络通信

---

#### 2 线程之间通信

1. **volatile关键词（共享内存）**：多个线程监听一个内存中的变量，根据变量变化，执行相应任务
2. **Object 类的 wait() 和notify() 方法**：`wait()、notify()、notifyAll()` 用于多线程通信，配合 `synchronized` 使用，`notify()` 不释放锁，`wait()` 释放锁
3. **ReentrantLock 与 Condition结合**：`await()、signal()、signalAll()`配合`ReentrantLock`使用
4. **JUC 工具 `CountDownLatch`**：一个线程(或者多个)， 等待另外N个线程完成某个事情之后才能执行。 类似计数器
5. **`CyclicBarrier`**：N个线程相互等待，任何一个线程完成之前，所有的线程都必须等待。类似水闸

---

#### 3 进程的状态

- **创建状态(new)** ：进程正在被创建，尚未到就绪状态。
- **就绪状态(ready)** ：进程已处于准备运行状态，即进程获得了除了处理器之外的一切所需资源，一旦得到处理器资源(处理器分配的时间片)即可运行。
- **运行状态(running)** ：进程正在处理器上运行。
- **阻塞状态(waiting)** ：又称为等待状态，进程正在等待某一事件而暂停运行如等待某资源为可用或等待 IO 操作完成。即使处理器空闲，该进程也不能运行。
- **结束状态(terminated)** ：进程正在从系统中消失。可能是进程正常结束或其他原因中断退出运行。

---

#### Linux命令