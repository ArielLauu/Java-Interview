## 操作系统

[TOC]

#### 进程之间通信

1. **管道/匿名管道** 
   - 半双工，数据往一个方向流动
   - 只能用于父子/兄弟进程之间
   - 数据FIFO，每次添加在尾部，从头部读
   - 存在于内存中
   - 读写进程必须同时在，否则阻塞
2. **有名管道**
   - 支持本机任意两个进程通信
   - FIFO，单向数据流
   - 管道的名字存储在文件系统，内容存放在内存，通过路径+文件名访问有名管道
   - 读写进程必须同时在，否则阻塞
3. **信号**：用于通知接收进程发生了某件事
4. **消息队列**
   - 存在于内核中的消息链表
   - 一个进程往队列写入消息时，并不需要另一个读进程在队列上等待消息到达
   - 支持消息随机查询，支持多个进程写入or读取
5. **共享内存**：内核中的一块区域。需要访问该区域的进程，将其映射到自己的私有地址空间，就可以直接进行数据的读写。需要依靠同步机制进行同步，如信号量
6. **信号量**：用于多进程对共享数据的访问，为非负整形变量，可被创建、等待或挂出
7. **套接字（socket)**：一种支持TCP/IP的通信机制，支持进程跨网络通信

---

#### 线程之间通信

1. **volatile关键词（共享内存）**：多个线程监听一个内存中的变量，根据变量变化，执行相应任务
2. **Object 类的 wait() 和notify() 方法**：`wait()、notify()、notifyAll()` 用于多线程通信，配合 `synchronized` 使用，`sleep()` 不释放锁，`wait()` 释放锁
3. **ReentrantLock 与 Condition结合**：`await()、signal()、signalAll()`配合`ReentrantLock`使用
4. **JUC 工具 `CountDownLatch`**：一个线程(或者多个)， 等待另外N个线程完成某个事情之后才能执行。 类似计数器
5. **`CyclicBarrier`**：N个线程相互等待，任何一个线程完成之前，所有的线程都必须等待。类似水闸

---

#### 进程的状态

- **创建状态(new)** ：进程正在被创建，尚未到就绪状态。
- **就绪状态(ready)** ：进程已处于准备运行状态，即进程获得了除了处理器之外的一切所需资源，一旦得到处理器资源(处理器分配的时间片)即可运行。
- **运行状态(running)** ：进程正在处理器上运行。
- **阻塞状态(waiting)** ：又称为等待状态，进程正在等待某一事件而暂停运行如等待某资源为可用或等待 IO 操作完成。即使处理器空闲，该进程也不能运行。
- **结束状态(terminated)** ：进程正在从系统中消失。可能是进程正常结束或其他原因中断退出运行。

---

#### 什么是虚拟内存

**定义**：虚拟内存为每一个进程提供了一个一致的，私有的地址空间，它让每个进程产生一种自己在独享主存的错觉，即每个进程仿佛拥有一个完整的内存空间。而实际上，它通常是被分成多个物理内存碎片，甚至还有部分暂时存储外部磁盘存储器上，在需要时进行数据交换。

虚拟内存的重要意义，是**它定义了一个连续的虚拟地址空间**，并且把**内存扩展到硬盘空间**。

**物理内存：**就是机器本身内存（如内存条的大小）。物理内存就是CPU的地址线可以直接进行寻址的内存空间大小

---

#### 分页机制和分段机制的共同点和区别

- **页式管理**：把内存分为大小相等且固定的一页一页的形式。分页仅仅是系统管理上的需要，对用户不可见。通过页表对应逻辑地址和物理地址

- **段式管理**：页式管理虽然提高了主存利用率，但是页并无任何实际意义。段式管理管理把主存分为一段一段的，每个段定义了一组逻辑信息，如主程序段 MAIN、子程序段 X、数据段 D 及栈段 S 等。分段对用户是可见的，可以更好的满足用户的需求。 段式管理通过段表对应逻辑地址和物理地址。

**共同点**：

1. 都是为了提高内存利用率，减少内存碎片
2. 页和段都是离散存储的，所以两者都是离散分配的方式。但是页和段内部的空间都是连续的

**区别**：

1. 页的大小是固定的，由操作系统决定；段的大小不固定，取决于当前运行的程序
2. 分页仅仅是为了满足操作系统内存管理的需求。而段是逻辑信息的单位，在程序中可以体现为代码段，数据段。

https://www.cnblogs.com/wkfvawl/p/11733057.html

---

#### 缺页中断 + 页面置换算法

**缺页中断**：地址映射过程中，发现所要访问的页面不在内存中，则发生缺页中断 。由处理器通知操作系统将相应的页调入内存，然后继续执行程序。

当发生缺页中断时，如果当前内存中并没有空闲的页面，操作系统就必须在内存选择一个页面将其移出内存，以便为即将调入的页面让出空间。用来选择淘汰哪一页的规则叫做页面置换算法，我们可以把页面置换算法看成是淘汰页面的规则。

- **OPT 页面置换算法（最佳页面置换算法）** ：最佳(Optimal, OPT)置换算法所选择的被淘汰页面将是以后永不使用的，或者是在最长时间内不再被访问的页面,这样可以保证获得最低的缺页率。但由于人们目前无法预知进程在内存下的若千页面中哪个是未来最长时间内不再被访问的，因而该算法无法实现。一般作为衡量其他置换算法的方法。
- **FIFO（First In First Out） 页面置换算法（先进先出页面置换算法）** : 总是淘汰最先进入内存的页面，即选择在内存中驻留时间最久的页面进行淘汰。
- **LRU （Least Currently Used）页面置换算法（最近最久未使用页面置换算法）** ：LRU算法赋予每个页面一个访问字段，用来记录一个页面自上次被访问以来所经历的时间 T，当须淘汰一个页面时，选择现有页面中其 T 值最大的，即最近最久未使用的页面予以淘汰。
- **LFU （Least Frequently Used）页面置换算法（最少使用页面置换算法）** : 该置换算法选择在之前时期使用最少的页面作为淘汰页。

---

#### Linux命令

1. **grep**： 在给定的文件中搜寻指定的字符串。`grep -i` 在搜寻时会忽略字符串的大小写，而`grep -r` 则会在当前工作目录的文件中递归搜寻指定的字符串。
2. **find**：这个命令会在给定位置搜寻与条件匹配的文件。你可以使用`find -name` 的-name选项来进行区分大小写的搜寻，`find -iname` 来进行不区分大小写的搜寻。
3. **ps**：ps显示系统的运行进程。`ps -e`显示所有进程，`ps -f`显示进程间关系，`ps -ef| grep java`显示带有java关键字的所有进程
4. **top**：top命令会默认按照CPU的占用情况，显示占用量较大的进程
5. **df**：df以磁盘分区为单位查看文件系统，可以获取硬盘被占用了多少空间，目前还剩下多少空间等信息。`df -hl` 查看磁盘剩余空间

cd pwd ls cp mv mkdir rm