## 数据库

[TOC]

#### 事务隔离级别 ( 隔离级别的实现方式 )

- **READ-UNCOMMITTED(读取未提交)：** 最低的隔离级别，允许读取尚未提交的数据变更，**可能会导致脏读、幻读或不可重复读**。
- **READ-COMMITTED(读取已提交)：** 允许读取并发事务已经提交的数据，**可以阻止脏读，但是幻读或不可重复读仍有可能发生**。
- **REPEATABLE-READ(可重复读)：** 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，**可以阻止脏读和不可重复读，但幻读仍有可能发生**。
- **SERIALIZABLE(可串行化)：** 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，**该级别可以防止脏读、不可重复读以及幻读**。

---

#### 数据库范式

范式一级比一级要求得严格，越高的范式数据库冗余越小

- **第一范式（1NF）**：数据库表的每一列都是**不可分割**的原子数据项

- **第二范式（2NF）**：任何一个非码属性（不在主键中的列）都必须**完全函数依赖于主属性**（在1NF基础上消除非主属性对主属性的部分依赖）

- **第三范式（3NF）**：任何**非主属性不依赖于其它非主属性**（在2NF基础上消除传递依赖）

- **BCNF（巴斯-科德范式**）：任何非主属性不能对主键子集依赖（在3NF基础上消除对主码子集的依赖）

- 第四范式（消除多值依赖）

---

#### MySQL默认隔离级别

- MySQL InnoDB引擎默认支持`REPEATABLE-READ`，但是在该事务隔离级别下，允许使用`Next-Key Lock`锁算法来避免幻读
- InnoDB支持行级锁和表级锁，默认为**行级锁**

**InnoDB存储引擎的锁算法**：

- `Record Lock`：锁定单条**索引**（不是锁记录，而是仅锁定索引）
- `Gap Lock`：**间隙锁**，锁定一个范围，不包括记录本身
- `Next-key Lock`：`Record+Gap`，锁定一个范围，包含记录本身。InnoDB扫描索引记录时，会先对索引记录加上行锁（Record Lock），再对索引两边记录的间隙加上间隙锁（Gap Lock)

---

#### MVCC原理（如何使用MVCC解决不可重复读问题）

总结：https://blog.csdn.net/Waves___/article/details/105295060

多版本并发控制（Multi-Version Concurrency Control, **MVCC**）是InnoDB引擎实现隔离级别的一种方式。用于实现`Read Committed`、`Repeatable Read`。MVC的实现依赖于**隐藏字段**、**Read View**和**Undo log**。

**1 隐藏字段**

每行数据的后面都有三个隐藏字段：

1. **`DB_TRX_ID`**：表示最近一次对本记录做修改（`insert|update`）的事务ID，`delete`行为会被当做一个`update`操作，并更新一个另外的删除位，记录为deleted
2. **`DB_ROLL_PTR`**：回滚指针，指向当先记录行的`undo log`信息
3. **`DB_ROW_ID`**：随着新行插入而单调递增的行ID。（当表没有主键或唯一非空索引时，innodb就会使用这个行ID自动产生聚簇索引。如果表有主键或唯一非空索引，聚簇索引就不会包含这个行ID了。）**这个DB_ROW_ID跟MVCC关系不大**

**2 Read View**

包含的变量：

- **`low_limit_id`**：目前出现过的最大事务`ID+1`，即下一个将被分配的事务ID
- **`up_limit_id`**：未提交事务列表`trx_ids`中最小的事务ID，如果`trx_ids`为空，则`up_limit_id`为`low_limit_id`
- **`trx_ids`**: `Read View`创建时其他未提交的活跃事务ID列表
- `creator_trx_id`：当前创建事务的ID

**3 Undo Log**

- `Undo Log`中存储老版本数据，当事务需要读取记录行时，如果当前记录行不可见，就会顺着`undo log`链找到符合可见性的记录行版本。

- `db_roll_ptr`把一个数据行的所有快照连接起来

![img](数据库.assets/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f696d6167652d32303139313230383136343830383231372e706e67)

`Undo Log`分为以下两类：

1. `insert undo log`：事务`insert`新记录时产生，只在事务回滚时需要，并且在事务提交后就可以立即丢弃
2. `update undo log`：事务`update/delete`操作时产生，在事务回滚和快照读时都需要

**4 可见性比较算法**

InnoDB中，开始一个事务后，对于**可重复读**隔离级别，执行**第一条 **`select`语句后，会创建一个快照，即`Read View`（**读提交**隔离级别是**每条Select语句**都会重新创建`Read View`）。

当用户在这个事务中，要读取某个记录行时，需要比较该记录行的`DB_TRX_ID`（下面的`trx_id`）与 Read View中的一些参数，判断是否满足可见性条件。

**具体算法**：

1. 如果 **trx_id < up_limit_id**, 那么表明 “最新修改该行的事务” 在 “当前事务” 创建快照之前就提交了，所以该记录行的值对当前事务是可见的，因此可以使用。
2. 如果 **trx_id >= low_limit_id**, 那么表明 “最新修改该行的事务” 在 “当前事务” 创建快照之后才修改该行，所以该记录行的值对当前事务不可见。该数据不可使用。
3. 如果 **up_limit_id <= trx_id < low_limit_id**, 需要**根据隔离级别**再进行判断：
   - **读提交**：如果`trx_id`在`trx_ids`列表中，则该数据快照对应的事务还未提交，快照不可以使用。否则可以使用
   - **可重复读**：都不可以使用。如果可以使用的话，其他事务也可以读取到这个数据快照并修改，当前事务再去读这个数据时，得到的值就会发生改变，出现了不可重复读。

---

#### MySQL存储引擎以及区别

**1 InnoDB**

现在是MySQL默认的事务型存储引擎，实现了四个标准的隔离级别，默认是可重复读。在可重复读隔离级别下，通过MVCC和Next-Key Lock防止幻读。

主索引是聚簇索引，在索引中保存了数据，从而避免直接读取磁盘，提升了查询性能。

内部做了很多优化，包括从磁盘读取数据时的可预测读、能加快读操作并且自动创建的自适应哈希索引、能够加快插入操作的插入缓冲区等。

支持在线热备份。

**2 MyISAM**

设计简单，数据以紧密格式存储。对于读较多，不需要事务，且可以容忍修复操作，则可以用它

提供了压缩表、空间数据索引等特性。

不支持事务、行级锁，只支持表级锁

可以手工或者自动执行检查和修复操作，但是可能导致一些数据丢失，且修复操作很慢。

**3 比较**

- 事务：InnoDB 是事务型的，可以使用 Commit 和 Rollback 语句。
- 并发：MyISAM 只支持表级锁，而 InnoDB 还支持行级锁。
- 外键：InnoDB 支持外键。
- 备份：InnoDB 支持在线热备份。
- 崩溃恢复：MyISAM 崩溃后发生损坏的概率比 InnoDB 高很多，而且恢复的速度也更慢。
- 其它特性：MyISAM 支持压缩表和空间数据索引。

---

#### MySQL索引，底层实现

**1 B+树索引**

- 聚簇索引：数据和索引放在一块，找到了索引也就找到了数据。一个表只有一个聚簇索引
- 非聚簇索引：数据存储和索引分开，叶子节点存储对应的行，需要二次查找

  **1.1 InnoDB实现（聚簇索引+非聚簇索引）**

  其数据文件本身就是索引文件。相比于MyISAM的索引文件和数据文件分离，InnoDB中数据文件本身就是按B+树组织的一个索引结构，树的节点Data域保存了完整的数据记录。这个索引的key是数据表的主键，因此InnoDB表本身就是主索引。而其他的索引都作为辅助索引，辅助索引的Data域存储相应的主键值而不是地址。

  在根据主键索引搜索时，直接找到key所在的节点即可取出数据；在根据辅助索引查找时，则需要先取出主键的值，再走一遍主索引。

  **1.2 MyISAM实现（非聚簇索引）**

  B+树节点的data域存放的是数据记录的**地址**。索引检索时，先按照B+树的搜索算法，搜索索引，如果指定的key存在，则取出其data值，然后以data值为地址读取相应的数据记录。

**2 Hash索引**

Hash索引支持O(1)时间查找，底层数据结构为哈希表，适用于绝大多数单条记录查询。缺点：

- 无法用于排序与分组
- 只支持精确查找，无法用于部分查找和范围查找

InnoDB存储引擎提供了“自适应哈希索引”，当某个索引值被非常频繁的使用，会在B+树索引上再创建一个哈希索引，让B+树索引具有哈希索引的一些优点，如快速查找

---

#### MySQL的联合索引

联合索引即由多列属性所组成的索引

**最左前缀原则**：如果查询的时候，查询条件精确匹配索引的左边的连续一列或者几列，则此列就可以被用到。所以在创建联合索引时，尽量把查询最频繁、索引值重复越少（每个记录区分度越高）的那个字段作为最左(第一个)字段

---

未整理：

mysql一套带走（ACID、并发控制、事务隔离级别、MVCC、undo段）

如何建立索引使得两条查询语句都走索引（考察联合索引、最左前缀匹配）

B+树和其它索引相比较的优点

谈一谈对慢查询的分析？MySQL常用的优化方法有哪些？

B+树索引和Hash索引的区别？

MySQL主从备份（mysql主从复制3个进程）