## 数据库

[TOC]

#### 事务隔离级别 ( 隔离级别的实现方式 )

- **READ-UNCOMMITTED(读取未提交)：** 最低的隔离级别，允许读取尚未提交的数据变更，**可能会导致脏读、幻读或不可重复读**。
- **READ-COMMITTED(读取已提交)：** 允许读取并发事务已经提交的数据，**可以阻止脏读，但是幻读或不可重复读仍有可能发生**。
- **REPEATABLE-READ(可重复读)：** 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，**可以阻止脏读和不可重复读，但幻读仍有可能发生**。
- **SERIALIZABLE(可串行化)：** 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，**该级别可以防止脏读、不可重复读以及幻读**。

---

#### 数据库范式

范式一级比一级要求得严格，越高的范式数据库冗余越小

- **第一范式（1NF）**：数据库表的每一列都是**不可分割**的原子数据项
- **第二范式（2NF）**：任何一个非码属性（不在主键中的列）都必须**完全函数依赖于主属性**（在1NF基础上消除非主属性对主属性的部分依赖）
- **第三范式（3NF）**：任何**非主属性不依赖于其它非主属性**（在2NF基础上消除传递依赖）
- **BCNF（巴斯-科德范式**）：任何非主属性不能对主键子集依赖（在3NF基础上消除对主码子集的依赖）
- 第四范式（消除多值依赖）

参考链接：https://segmentfault.com/a/1190000013695030

---

#### MySQL默认隔离级别

- MySQL InnoDB引擎默认支持`REPEATABLE-READ`，但是在该事务隔离级别下，允许使用`Next-Key Lock`锁算法来避免幻读
- InnoDB支持行级锁和表级锁，默认为**行级锁**

**InnoDB存储引擎的锁算法**：

- `Record Lock`：锁定单条**索引**（不是锁记录，而是仅锁定索引）
- `Gap Lock`：**间隙锁**，锁定一个范围，不包括记录本身。Gap锁设计的目的是为了阻止多个事务将记录插入到同一范围内，而这会导致幻读问题的产生
- `Next-key Lock`：`Record+Gap`，锁定一个范围，包含记录本身。InnoDB扫描索引记录时，会先对索引记录加上行锁（Record Lock），再对索引两边记录的间隙加上间隙锁（Gap Lock)

---

#### 数据库死锁（待整理）

共享锁、排他锁，select for update语句

---

#### MVCC原理（如何使用MVCC解决不可重复读问题）

总结：https://blog.csdn.net/Waves___/article/details/105295060

多版本并发控制（Multi-Version Concurrency Control, **MVCC**）是InnoDB引擎实现隔离级别的一种方式。用于实现`Read Committed`、`Repeatable Read`。MVC的实现依赖于**隐藏字段**、**Read View**和**Undo log**。

**1 隐藏字段**

每行数据的后面都有三个隐藏字段：

1. **`DB_TRX_ID`**：表示最近一次对本记录做修改（`insert|update`）的事务ID，`delete`行为会被当做一个`update`操作，并更新一个另外的删除位，记录为deleted
2. **`DB_ROLL_PTR`**：回滚指针，指向当前记录行的`undo log`信息
3. **`DB_ROW_ID`**：随着新行插入而单调递增的行ID。（当表没有主键或唯一非空索引时，innodb就会使用这个行ID自动产生聚簇索引。如果表有主键或唯一非空索引，聚簇索引就不会包含这个行ID了。）**这个DB_ROW_ID跟MVCC关系不大**

**2 Read View**

包含的变量：

- **`low_limit_id`**：目前出现过的最大事务`ID+1`，即下一个将被分配的事务ID
- **`up_limit_id`**：未提交事务列表`trx_ids`中最小的事务ID，如果`trx_ids`为空，则`up_limit_id`为`low_limit_id`
- **`trx_ids`**: `Read View`创建时其他未提交的活跃事务ID列表
- `creator_trx_id`：当前创建事务的ID

**3 Undo Log**

- `Undo Log`中存储老版本数据，当事务需要读取记录行时，如果当前记录行不可见，就会顺着`undo log`链找到符合可见性的记录行版本。

- `db_roll_ptr`把一个数据行的所有回滚段连接起来

![img](https://typora-image-ariellauu.oss-cn-beijing.aliyuncs.com/uPic/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f696d6167652d32303139313230383136343830383231372e706e67.jpg)

`Undo Log`分为以下两类：

1. `insert undo log`：事务`insert`新记录时产生，只在事务回滚时需要，并且在事务提交后就可以立即丢弃
2. `update undo log`：事务`update/delete`操作时产生，在事务回滚和快照读时都需要

**4 可见性比较算法**

InnoDB中，开始一个事务后，对于**可重复读**隔离级别，执行**第一条 **`select`语句后，会创建一个快照，即`Read View`（**读提交**隔离级别是**每条Select语句**都会重新创建`Read View`，这样才能读到已提交的数据https://blog.csdn.net/n88Lpo/article/details/78126270）。

当用户在这个事务中，要读取某个记录行时，需要比较该记录行的`DB_TRX_ID`（下面的`trx_id`）与 Read View中的一些参数，判断是否满足可见性条件。

**具体算法**：

1. 如果 **trx_id < up_limit_id**, 那么表明 “最新修改该行的事务” 在 “当前事务” 创建快照之前就提交了，所以该记录行的值对当前事务是可见的，因此可以使用。
2. 如果 **trx_id >= low_limit_id**, 那么表明 “最新修改该行的事务” 在 “当前事务” 创建快照之后才修改该行，所以该记录行的值对当前事务不可见。该数据不可使用。
3. 如果 **up_limit_id <= trx_id < low_limit_id**, 需要**根据隔离级别**再进行判断：
   - **读提交**：如果`trx_id`在`trx_ids`列表中，则该数据快照对应的事务还未提交，快照不可以使用。否则可以使用
   - **可重复读**：都不可以使用。如果可以使用的话，其他事务也可以读取到这个数据快照并修改，当前事务再去读这个数据时，得到的值就会发生改变，出现了不可重复读。

---

#### MySQL存储引擎以及区别

**1 InnoDB**

现在是MySQL默认的事务型存储引擎，实现了四个标准的隔离级别，默认是可重复读。在可重复读隔离级别下，通过MVCC和Next-Key Lock防止幻读。

主索引是聚簇索引，在索引中保存了数据，从而避免直接读取磁盘，提升了查询性能。

内部做了很多优化，包括从磁盘读取数据时的可预测读、能加快读操作并且自动创建的自适应哈希索引、能够加快插入操作的插入缓冲区等。

支持在线热备份。

**2 MyISAM**

设计简单，数据以紧密格式存储。对于读较多，不需要事务，且可以容忍修复操作，则可以用它

提供了压缩表、空间数据索引等特性。

不支持事务、行级锁，只支持表级锁

可以手工或者自动执行检查和修复操作，但是可能导致一些数据丢失，且修复操作很慢。

**3 比较**

- 事务：InnoDB 是事务型的，可以使用 Commit 和 Rollback 语句。
- 并发：MyISAM 只支持表级锁，而 InnoDB 还支持行级锁。
- 外键：InnoDB 支持外键。
- 备份：InnoDB 支持在线热备份。
- 崩溃恢复：MyISAM 崩溃后发生损坏的概率比 InnoDB 高很多，而且恢复的速度也更慢。
- 其它特性：MyISAM 支持压缩表和空间数据索引。

---

#### MySQL索引，底层实现

**1 B+树索引**

- 聚簇索引：数据和索引放在一块，找到了索引也就找到了数据。一个表只有一个聚簇索引
- 非聚簇索引：数据存储和索引分开，叶子节点存储对应的行，需要二次查找

  **1.1 InnoDB实现（聚簇索引+非聚簇索引）**

  其数据文件本身就是索引文件。相比于MyISAM的索引文件和数据文件分离，InnoDB中数据文件本身就是按B+树组织的一个索引结构，树的节点Data域保存了完整的数据记录。这个索引的key是数据表的主键，因此InnoDB表本身就是主索引。而其他的索引都作为辅助索引，辅助索引的Data域存储相应的主键值而不是地址。

  在根据主键索引搜索时，直接找到key所在的节点即可取出数据；在根据辅助索引查找时，则需要先取出主键的值，再走一遍主索引。

  **1.2 MyISAM实现（非聚簇索引）**

  B+树节点的data域存放的是数据记录的**地址**。索引检索时，先按照B+树的搜索算法，搜索索引，如果指定的key存在，则取出其data值，然后以data值为地址读取相应的数据记录。

**2 Hash索引**

Hash索引支持O(1)时间查找，底层数据结构为哈希表，适用于绝大多数单条记录查询。缺点：

- 无法用于排序与分组
- 只支持精确查找，无法用于部分查找和范围查找

InnoDB存储引擎提供了“自适应哈希索引”，当某个索引值被非常频繁的使用，会在B+树索引上再创建一个哈希索引，让B+树索引具有哈希索引的一些优点，如快速查找

参考资料：https://www.kancloud.cn/kancloud/theory-of-mysql-index/41850

---

#### MySQL引擎为什么使用 B+ 树

- 本质都是因为数据存在磁盘中，要减少读取磁盘的次数，磁盘每次读取一页（一个磁盘块)

  - AVL 树： 高度太高，需要保证树的平衡，每个节点只能存一个键和数据，需要频繁 IO

  - B树:  每个节点(页)存储了更多的键值和数据

  - B+树:  除了叶结点，内部节点不存储数据，那么就会存储更多的键值，树的阶数就更大，树更矮 ，IO 少

    (单次磁盘IO的信息量大于B树，I/O的次数相对减少)

- 所有记录存放在叶子结点上，并且是**顺序存放** (数据使用单向链表链接)，使得范围查找，排序查找，分组查找以及去重查找变得异常简单，而MySQL是一种关系型数据库，区间访问是常见的一种情况

##### 为什么不用红黑树

磁盘本身存取就比主存慢很多，因此为了提高效率，要尽量减少磁盘I/O。为了达到这个目的，磁盘往往不是严格按需读取，而是每次都会预读，即使只需要一个字节，磁盘也会从这个位置开始，顺序向后读取一定长度的数据放入内存。这样做的理论依据是计算机科学中著名的局部性原理： 

当一个数据被用到时，其附近的数据也通常会马上被使用。 

程序运行期间所需要的数据通常比较集中。 

由于**磁盘顺序读取的效率很高**（不需要寻道时间，只需很少的旋转时间），因此对于具有局部性的程序来说，预读可以提高I/O效率。

**红黑树这种结构，h明显要深的多。由于逻辑上很近的节点（父子）物理上可能很远，无法利用局部性，**所以红黑树的I/O渐进复杂度也为O(h)，效率明显比B-Tree差很多。

---

#### MySQL的联合索引

联合索引即由多列属性所组成的索引

**最左前缀原则**：如果查询的时候，查询条件精确匹配索引的左边的连续一列或者几列，则此列就可以被用到。所以在创建联合索引时，尽量把查询最频繁、索引值重复越少（每个记录区分度越高）的那个字段作为最左(第一个)字段

---

#### 左连接右连接区别

- **左连接**：左表(a_table)的记录将会全部表示出来，而右表(b_table)只会显示符合搜索条件的记录，右表记录不符合搜索条件的地方均为NULL

- **右连接**：右表(b_table)的记录将会全部表示出来，左表(a_table)只会显示符合搜索条件的记录，记录不符合搜索条件的地方均为NULL。

---

#### MySQL开启事务的完整过程

https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247485097&idx=1&sn=84c89da477b1338bdf3e9fcd65514ac1&chksm=cea24962f9d5c074d8d3ff1ab04ee8f0d6486e3d015cfd783503685986485c11738ccb542ba7&token=79317275&lang=zh_CN#rd

---

#### 数据库语句执行很慢的原因

一个 SQL 执行的很慢，我们要分两种情况讨论：

1、**大多数情况下很正常，偶尔很慢**，则有如下原因

(1)、数据库在刷新脏页，例如 redo log 写满了需要同步到磁盘。

(2)、执行的时候，遇到锁，如表锁、行锁。

2、**这条 SQL 语句一直执行的很慢**，则有如下原因。

(1)、没有用上索引：例如该字段没有索引；由于对字段进行运算、函数操作导致无法用索引。

(2)、数据库选错了索引。

https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247485185&idx=1&sn=66ef08b4ab6af5757792223a83fc0d45&chksm=cea248caf9d5c1dc72ec8a281ec16aa3ec3e8066dbb252e27362438a26c33fbe842b0e0adf47&token=79317275&lang=zh_CN#rd

---

#### MySQL查询优化（建索引的原则）

**1. 如何选择索引列的顺序**

​	建立索引的目的是：希望通过索引进行数据查找，减少随机 IO，增加查询性能 ，索引能过滤出越少的数据，则从磁盘中读入的数据也就越少。 **注意最左前缀原则**

- **区分度最高**的放在联合索引的最左侧（区分度=列中不同值的数量/列的总行数）
- 尽量把**字段长度小**的列放在联合索引的最左侧（因为字段长度越小，一页能存储的数据量越大，IO 性能也就越好）
- **使用最频繁**的列放到联合索引的左侧（这样可以比较少的建立一些索引）

**2. 对于频繁的查询优先考虑使用覆盖索引**

- **避免 Innodb 表进行索引的二次查询**：Innodb 是以聚集索引的顺序来存储的，对于 Innodb 来说，二级索引在叶子节点中所保存的是行的主键信息，如果是用二级索引查询数据的话，在查找到相应的键值后，还要通过主键进行二次查询才能获取我们真实所需要的数据。而在覆盖索引中，二级索引的键值中可以获取所有的数据，避免了对主键的二次查询 ，减少了 IO 操作，提升了查询效率。
- **可以把随机 IO 变成顺序 IO 加快查询效率**: 由于覆盖索引是按键值的顺序存储的，对于 IO 密集型的范围查找来说，对比随机从磁盘读取每一行的数据 IO 要少的多，因此利用覆盖索引在访问时也可以把磁盘的随机读取的 IO 转变成索引查找的顺序 IO。

---

#### 手写SQL



---

未整理：

mysql一套带走（ACID、并发控制、事务隔离级别、MVCC、undo段）

如何建立索引使得两条查询语句都走索引（考察联合索引、最左前缀匹配）

B+树和其它索引相比较的优点（B+树和hash索引区别）

谈一谈对慢查询的分析？MySQL常用的优化方法有哪些？

MySQL主从备份（mysql主从复制3个进程）



