## 数据库

[TOC]

#### 事务隔离级别 ( 隔离级别的实现方式 )

- **READ-UNCOMMITTED(读取未提交)：** 最低的隔离级别，允许读取尚未提交的数据变更，**可能会导致脏读、幻读或不可重复读**。
- **READ-COMMITTED(读取已提交)：** 允许读取并发事务已经提交的数据，**可以阻止脏读，但是幻读或不可重复读仍有可能发生**。
- **REPEATABLE-READ(可重复读)：** 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，**可以阻止脏读和不可重复读，但幻读仍有可能发生**。
- **SERIALIZABLE(可串行化)：** 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，**该级别可以防止脏读、不可重复读以及幻读**。

---

#### 数据库范式

范式一级比一级要求得严格，越高的范式数据库冗余越小

- **第一范式（1NF）**：数据库表的每一列都是**不可分割**的原子数据项
- **第二范式（2NF）**：任何一个非码属性（不在主键中的列）都必须**完全函数依赖于主属性**（在1NF基础上消除非主属性对主属性的部分依赖）
- **第三范式（3NF）**：任何**非主属性不依赖于其它非主属性**（在2NF基础上消除传递依赖）
- **BCNF（巴斯-科德范式**）：任何非主属性不能对主键子集依赖（在3NF基础上消除对主码子集的依赖）
- 第四范式（消除多值依赖）

参考链接：https://segmentfault.com/a/1190000013695030

---

#### MySQL默认隔离级别

- MySQL InnoDB引擎默认支持`REPEATABLE-READ`，但是在该事务隔离级别下，允许使用`Next-Key Lock`锁算法来避免幻读
- InnoDB支持行级锁和表级锁，默认为**行级锁**

**InnoDB存储引擎的锁算法**：

- `Record Lock`：锁定单条**索引**（不是锁记录，而是仅锁定索引）
- `Gap Lock`：**间隙锁**，锁定一个范围，不包括记录本身。Gap锁设计的目的是为了阻止多个事务将记录插入到同一范围内，而这会导致幻读问题的产生
- `Next-key Lock`：`Record+Gap`，锁定一个范围，包含记录本身。InnoDB扫描索引记录时，会先对索引记录加上行锁（Record Lock），再对索引两边记录的间隙加上间隙锁（Gap Lock)

---

#### 数据库死锁（待整理）

共享锁、排他锁，select for update语句

https://blog.csdn.net/tr1912/article/details/81668423

---

#### MVCC原理（如何使用MVCC解决不可重复读问题）

总结：https://blog.csdn.net/Waves___/article/details/105295060

多版本并发控制（Multi-Version Concurrency Control, **MVCC**）是InnoDB引擎实现隔离级别的一种方式。用于实现`Read Committed`、`Repeatable Read`。MVC的实现依赖于**隐藏字段**、**Read View**和**Undo log**。

**1 隐藏字段**

每行数据的后面都有三个隐藏字段：

1. **`DB_TRX_ID`**：表示最近一次对本记录做修改（`insert|update`）的事务ID，`delete`行为会被当做一个`update`操作，并更新一个另外的删除位，记录为deleted
2. **`DB_ROLL_PTR`**：回滚指针，指向当前记录行的`undo log`信息
3. **`DB_ROW_ID`**：随着新行插入而单调递增的行ID。（当表没有主键或唯一非空索引时，innodb就会使用这个行ID自动产生聚簇索引。如果表有主键或唯一非空索引，聚簇索引就不会包含这个行ID了。）**这个DB_ROW_ID跟MVCC关系不大**

**2 Read View**

包含的变量：

- **`low_limit_id`**：目前出现过的最大事务`ID+1`，即下一个将被分配的事务ID
- **`up_limit_id`**：未提交事务列表`trx_ids`中最小的事务ID，如果`trx_ids`为空，则`up_limit_id`为`low_limit_id`
- **`trx_ids`**: `Read View`创建时其他未提交的活跃事务ID列表
- `creator_trx_id`：当前创建事务的ID

**3 Undo Log**

- `Undo Log`中存储老版本数据，当事务需要读取记录行时，如果当前记录行不可见，就会顺着`undo log`链找到符合可见性的记录行版本。

- `db_roll_ptr`把一个数据行的所有回滚段连接起来

![img](https://typora-image-ariellauu.oss-cn-beijing.aliyuncs.com/uPic/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f696d6167652d32303139313230383136343830383231372e706e67.jpg)

`Undo Log`分为以下两类：

1. `insert undo log`：事务`insert`新记录时产生，只在事务回滚时需要，并且在事务提交后就可以立即丢弃
2. `update undo log`：事务`update/delete`操作时产生，在事务回滚和快照读时都需要

**4 可见性比较算法**

InnoDB中，开始一个事务后，对于**可重复读**隔离级别，执行**第一条 **`select`语句后，会创建一个快照，即`Read View`（**读提交**隔离级别是**每条Select语句**都会重新创建`Read View`，这样才能读到已提交的数据https://blog.csdn.net/n88Lpo/article/details/78126270）。

当用户在这个事务中，要读取某个记录行时，需要比较该记录行的`DB_TRX_ID`（下面的`trx_id`）与 Read View中的一些参数，判断是否满足可见性条件。

**具体算法**：

1. 如果 **trx_id < up_limit_id**, 那么表明 “最新修改该行的事务” 在 “当前事务” 创建快照之前就提交了，所以该记录行的值对当前事务是可见的，因此可以使用。
2. 如果 **trx_id >= low_limit_id**, 那么表明 “最新修改该行的事务” 在 “当前事务” 创建快照之后才修改该行，所以该记录行的值对当前事务不可见。该数据不可使用。
3. 如果 **up_limit_id <= trx_id < low_limit_id**, 需要**根据隔离级别**再进行判断：
   - **读提交**：如果`trx_id`在`trx_ids`列表中，则该数据快照对应的事务还未提交，快照不可以使用。否则可以使用
   - **可重复读**：都不可以使用。如果可以使用的话，其他事务也可以读取到这个数据快照并修改，当前事务再去读这个数据时，得到的值就会发生改变，出现了不可重复读。

---

#### MySQL存储引擎以及区别

**1 InnoDB**

现在是MySQL默认的事务型存储引擎，实现了四个标准的隔离级别，默认是可重复读。在可重复读隔离级别下，通过MVCC和Next-Key Lock防止幻读。

主索引是聚簇索引，在索引中保存了数据，从而避免直接读取磁盘，提升了查询性能。

内部做了很多优化，包括从磁盘读取数据时的可预测读、能加快读操作并且自动创建的自适应哈希索引、能够加快插入操作的插入缓冲区等。

支持在线热备份。

**2 MyISAM**

设计简单，数据以紧密格式存储。对于读较多，不需要事务，且可以容忍修复操作，则可以用它

提供了压缩表 (对不会修改的表，支持压缩表，缩减存储空间)、空间数据索引等特性。

不支持事务、行级锁，只支持表级锁

可以手工或者自动执行检查和修复操作，但是可能导致一些数据丢失，且修复操作很慢。

**3 比较**

- 事务：InnoDB 是事务型的，可以使用 Commit 和 Rollback 语句。
- 并发：MyISAM 只支持表级锁，而 InnoDB 还支持行级锁。
- 外键：InnoDB 支持外键。
- 备份：InnoDB 支持在线热备份。
- 崩溃恢复：MyISAM 崩溃后发生损坏的概率比 InnoDB 高很多，而且恢复的速度也更慢。
- 其它特性：MyISAM 支持压缩表和空间数据索引。

总体来讲，MyISAM适合`SELECT`密集型的表，而InnoDB适合`INSERT`和`UPDATE`密集型的表

---

#### MySQL索引，底层实现

**1 B+树索引**

- 聚簇索引：数据和索引放在一块，找到了索引也就找到了数据。一个表只有一个聚簇索引
- 非聚簇索引：数据存储和索引分开，叶子节点存储对应的行，需要二次查找

  **1.1 InnoDB实现（聚簇索引+非聚簇索引）**

  其数据文件本身就是索引文件。相比于MyISAM的索引文件和数据文件分离，InnoDB中数据文件本身就是按B+树组织的一个索引结构，树的节点Data域保存了完整的数据记录。这个索引的key是数据表的主键，因此InnoDB表本身就是主索引。而其他的索引都作为辅助索引，辅助索引的Data域存储相应的主键值而不是地址。

  在根据主键索引搜索时，直接找到key所在的节点即可取出数据；在根据辅助索引查找时，则需要先取出主键的值，再走一遍主索引。

  **1.2 MyISAM实现（非聚簇索引）**

  B+树节点的data域存放的是数据记录的**地址**。索引检索时，先按照B+树的搜索算法，搜索索引，如果指定的key存在，则取出其data值，然后以data值为地址读取相应的数据记录。

**2 Hash索引**

Hash索引支持O(1)时间查找，底层数据结构为哈希表，适用于绝大多数单条记录查询。缺点：

- 无法用于排序与分组
- 只支持精确查找，无法用于部分查找和范围查找

InnoDB存储引擎提供了“自适应哈希索引”，当某个索引值被非常频繁的使用，会在B+树索引上再创建一个哈希索引，让B+树索引具有哈希索引的一些优点，如快速查找

参考资料：https://www.kancloud.cn/kancloud/theory-of-mysql-index/41850

---

#### MySQL引擎为什么使用 B+ 树

- 本质都是因为数据存在磁盘中，要减少读取磁盘的次数，磁盘每次读取一页（一个磁盘块)

  - AVL 树： 高度太高，需要保证树的平衡，每个节点只能存一个键和数据，需要频繁 IO

  - B树:  每个节点(页)存储了更多的键值和数据

  - B+树:  除了叶结点，内部节点不存储数据，那么就会存储更多的键值，树的阶数就更大，树更矮 ，IO 少

    (单次磁盘IO的信息量大于B树，I/O的次数相对减少)

- 所有记录存放在叶子结点上，并且是**顺序存放** (数据使用单向链表链接)，使得范围查找，排序查找，分组查找以及去重查找变得异常简单，而MySQL是一种关系型数据库，区间访问是常见的一种情况

##### 为什么不用红黑树

磁盘本身存取就比主存慢很多，因此为了提高效率，要尽量减少磁盘I/O。为了达到这个目的，磁盘往往不是严格按需读取，而是每次都会预读，即使只需要一个字节，磁盘也会从这个位置开始，顺序向后读取一定长度的数据放入内存。这样做的理论依据是计算机科学中著名的局部性原理： 

当一个数据被用到时，其附近的数据也通常会马上被使用。 

程序运行期间所需要的数据通常比较集中。 

由于**磁盘顺序读取的效率很高**（不需要寻道时间，只需很少的旋转时间），因此对于具有局部性的程序来说，预读可以提高I/O效率。

**红黑树这种结构，h明显要深的多。由于逻辑上很近的节点（父子）物理上可能很远，无法利用局部性，**所以红黑树的I/O渐进复杂度也为O(h)，效率明显比B-Tree差很多。

---

#### MySQL的联合索引

联合索引即由多列属性所组成的索引

**最左前缀原则**：如果查询的时候，查询条件精确匹配索引的左边的连续一列或者几列，则此列就可以被用到。所以在创建联合索引时，尽量把查询最频繁、索引值重复越少（每个记录区分度越高）的那个字段作为最左(第一个)字段

---

#### 左连接右连接区别

- **左连接**：左表(a_table)的记录将会全部表示出来，而右表(b_table)只会显示符合搜索条件的记录，右表记录不符合搜索条件的地方均为NULL

- **右连接**：右表(b_table)的记录将会全部表示出来，左表(a_table)只会显示符合搜索条件的记录，记录不符合搜索条件的地方均为NULL。

---

#### Innodb 是怎么保证崩溃恢复能力

**两阶段提交**，MySQL 自带的日志模块式 `binlog` 和 InnoDB 引擎还自带日志模块 `redolog`

以一条更新语句为例：

1. 先查询到某数据，如果有缓存，也是会用到缓存 (mysql8以后移除)。
2. 然后拿到查询的语句，更新字段，然后调用引擎 API 接口，写入这一行数据，InnoDB 引擎把数据保存在内存中，同时**记录 redo log**，此时 redo log 进入 **prepare 状态**，然后告诉执行器，执行完成了，随时可以交。
3. 执行器收到通知后**记录 binlog**，然后调用引擎接口，提交 **redo log 为提交状态**。
4. 更新完成。

https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247485097&idx=1&sn=84c89da477b1338bdf3e9fcd65514ac1&chksm=cea24962f9d5c074d8d3ff1ab04ee8f0d6486e3d015cfd783503685986485c11738ccb542ba7&token=79317275&lang=zh_CN#rd

---

#### 数据库语句执行很慢的原因

一个 SQL 执行的很慢，我们要分两种情况讨论：

1、**大多数情况下很正常，偶尔很慢**，则有如下原因

(1)、数据库在刷新脏页，例如 redo log 写满了需要同步到磁盘。

(2)、执行的时候，遇到锁，如表锁、行锁。

2、**这条 SQL 语句一直执行的很慢**，则有如下原因。

(1)、没有用上索引：例如该字段没有索引；由于对字段进行运算、函数操作导致无法用索引。

(2)、数据库选错了索引。

https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247485185&idx=1&sn=66ef08b4ab6af5757792223a83fc0d45&chksm=cea248caf9d5c1dc72ec8a281ec16aa3ec3e8066dbb252e27362438a26c33fbe842b0e0adf47&token=79317275&lang=zh_CN#rd

---

#### MySQL索引失效的原因

1. like 以%开头，索引无效；当like前缀没有%，后缀有%时，索引有效
2. or语句前后没有同时使用索引。当or左右查询字段只有一个是索引，该索引失效，只有当or左右查询字段均为索引时，才会生效
3. 联合索引未符合最左前缀原则
4. 数据类型出现隐式转化。如varchar不加单引号的话可能会自动转换为int型，使索引无效，产生全表扫描
5. 在索引字段上使用not，<>，!=。不等于操作符是永远不会用到索引的，因此对它的处理只会产生全表扫描。 优化方法： key<>0 改为 key>0 or key<0。
6. 对索引字段进行计算操作、字段上使用函数
7. 当全表扫描速度比索引速度快时，mysql会使用全表扫描，此时索引失效

---

#### 如何优化SQL语句

1. **优先选择符合存储需要的最小的数据类型**

   **原因**：列的字段越大，建立索引时所需要的空间也就越大，这样一页中所能存储的索引节点的数量也就越少也越少，在遍历时所需要的 IO 次数也就越多，索引的性能也就越差

   eg：自增id优先用无符号整型，将字符串形式的IP 地址转换成整形数据

2. **禁止使用 SELECT * 必须使用 SELECT <字段列表> 查询**：无法使用覆盖索引；可减少表结构变更带来的影响

3. **insert**同理

4. **避免索引失效的情况**

5. **遵循建立索引的原则**

[MySQL高性能优化规范建议](https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247485117&idx=1&sn=92361755b7c3de488b415ec4c5f46d73&chksm=cea24976f9d5c060babe50c3747616cce63df5d50947903a262704988143c2eeb4069ae45420&token=79317275&lang=zh_CN#rd)

---

#### MySQL查询优化（建索引的原则）

**1. 如何选择索引列的顺序**

​	建立索引的目的是：希望通过索引进行数据查找，减少随机 IO，增加查询性能 ，索引能过滤出越少的数据，则从磁盘中读入的数据也就越少。 **注意最左前缀原则**

- **区分度最高**的放在联合索引的最左侧（区分度=列中不同值的数量/列的总行数）
- 尽量把**字段长度小**的列放在联合索引的最左侧（因为字段长度越小，一页能存储的数据量越大，IO 性能也就越好）
- **使用最频繁**的列放到联合索引的左侧（这样可以比较少的建立一些索引）

**2. 对于频繁的查询优先考虑使用覆盖索引**

- **避免 Innodb 表进行索引的二次查询**：Innodb 是以聚集索引的顺序来存储的，对于 Innodb 来说，二级索引在叶子节点中所保存的是行的主键信息，如果是用二级索引查询数据的话，在查找到相应的键值后，还要通过主键进行二次查询才能获取我们真实所需要的数据。而在覆盖索引中，二级索引的键值中可以获取所有的数据，避免了对主键的二次查询 ，减少了 IO 操作，提升了查询效率。
- **可以把随机 IO 变成顺序 IO 加快查询效率**: 由于覆盖索引是按键值的顺序存储的，对于 IO 密集型的范围查找来说，对比随机从磁盘读取每一行的数据 IO 要少的多，因此利用覆盖索引在访问时也可以把磁盘的随机读取的 IO 转变成索引查找的顺序 IO。

**3. 限制每张表上的索引数量，建议单张表索引不超过 5 个；禁止每一列都加索引**

---

#### 手写SQL

[手写SQL合集](https://zhuanlan.zhihu.com/p/38354000)

---

#### MySQL大表优化

**1. 读写分离**

也是目前常用的优化，从库读主库写，一般不要采用双主或多主引入很多复杂性，尽量采用文中的其他方案来提高性能。同时目前很多拆分的解决方案同时也兼顾考虑了读写分离

**2.  缓存**

服务层的缓存实现，目前主要有两种方式：

- 直写式（Write Through）：在数据写入数据库后，同时更新缓存，维持数据库与缓存的一致性。这也是当前大多数应用缓存框架如Spring Cache的工作方式。这种实现非常简单，同步好，但效率一般。
- 回写式（Write Back）：当有数据要写入数据库时，只会更新缓存，然后异步批量的将缓存数据同步到数据库上。这种实现比较复杂，需要较多的应用逻辑，同时可能会产生数据库与缓存的不同步，但效率非常高。

**3. 表分区**

用户需要在建表的时候加上分区参数，对应用是透明的无需修改代码。

如果数据有明显的热点，而且除了这部分数据，其他数据很少被访问到，那么可以将热点数据单独放在一个分区，让这个分区的数据能够有机会都缓存在内存中，查询时只访问一个很小的分区表，能够有效使用索引和缓存

**4. 垂直拆分**

**拆分策略**：

- 常见的是把一个多字段的大表按常用字段和非常用字段进行拆分，每个表里面的数据记录数一般情况下是相同的，只是字段不一样，**使用主键关联**
- 根据业务进行拆分
- **冷数据查询较多，更新较少**，适合用MyISAM引擎，而热**数据更新比较频繁**，适合使用InnoDB存储引擎，这也是垂直拆分的一种。
- 对读多写少的冷数据可配置更多的从库来化解大量查询请求的压力；对于热数据，可以使用多个主库构建分库分表的结构

**优点**：

- 可以使得行数据变小，一个数据块(Block)就能存放更多的数据，在查询时就会减少I/O次数(每次查询时读取的Block 就少)
- 拆分后业务清晰
- 可以达到最大化利用Cache的目的，具体在垂直拆分的时候可以将不常变的字段放一起，将经常改变的放一起
- 数据维护简单

**缺点**：

- 主键出现冗余，需要管理冗余列
- 会引起表连接JOIN操作（增加CPU开销）可以通过在业务服务器上进行join来减少数据库压力
- 依然存在单表数据量过大的问题（需要水平拆分）
- 事务处理复杂

**5. 水平拆分**

水平拆分是通过某种策略将数据分片来存储，分为**库内分表**和**分库**两部分，每片数据会分散到不同的MySQL表或库，达到分布式的效果，能够支持非常大的数据量。

**拆分策略**：

- **按照哈希切片**：应用于数据没有时效性的情况。好处是数据切片比较均匀，对数据压力分散的效果较好，缺点是数据分散后，对于查询需求需要进行聚合处理。
- **照时间切片**：用于有明显时间特点的数据
- **RANGE分区**：基于属于一个给定连续区间的列值，把多行分配给分区

水平拆分的优点是:

- 不存在单库大数据和高并发的性能瓶颈
- 应用端改造较少
- 提高了系统的稳定性和负载能力

缺点是：

- 分片事务一致性难以解决
- 跨节点Join性能差，逻辑复杂
- 数据多次扩展难度跟维护量极大

**水平拆分架构**

1. ##### 客户端架构

   通过修改数据访问层，如JDBC、Data Source、MyBatis，通过配置来管理多个数据源，直连数据库，并在模块内完成数据的分片整合，一般以Jar包的方式呈现

   **优点**：

   - 应用直连数据库，降低外围系统依赖所带来的宕机风险
   - 集成成本低，无需额外运维的组件

   **缺点**：

   - 限于只能在数据库访问层上做文章，扩展性一般，对于比较复杂的系统可能会力不从心
   - 将分片逻辑的压力放在应用服务器上，造成额外风险

   ![Alt text](https://typora-image-ariellauu.oss-cn-beijing.aliyuncs.com/uPic/1460000006158210.png)

2. ##### 代理架构

通过独立的中间件来统一管理所有数据源和数据分片整合，后端数据库集群对前端应用程序透明，需要独立部署和运维代理组件

**优点**：

- 能够处理非常复杂的需求，不受数据库访问层原来实现的限制，扩展性强
- 对于应用服务器透明且没有增加任何额外负载

**缺点**：

- 需部署和运维独立的代理中间件，成本高
- 应用需经过代理来连接数据库，网络上多了一跳，性能有损失且有额外风险

![Alt text](https://segmentfault.com/img/remote/1460000006767127)



未整理：

mysql一套带走（ACID、并发控制、事务隔离级别、MVCC、undo段）

如何建立索引使得两条查询语句都走索引（考察联合索引、最左前缀匹配）

B+树和其它索引相比较的优点（B+树和hash索引区别）

谈一谈对慢查询的分析？MySQL常用的优化方法有哪些？

MySQL主从备份（mysql主从复制3个进程）



